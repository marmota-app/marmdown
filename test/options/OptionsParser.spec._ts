/*
   Copyright [2020-2022] [David Tanzer - @dtanzer]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
import { ContentChange } from "$markdown/ContentChange"
import { Option, UpdatableOptions } from "$markdown/MarkdownOptions"
import { OptionParser } from "$markdown/options/OptionParser"
import { OptionsParser } from "$markdown/options/OptionsParser"
import { Parsers } from "$markdown/Parsers"

const NO_PARSERS: Parsers<never> = { names: () => [], knownParsers: () => ({}), toplevel: () => [], }
const PARSERS: Parsers<'OptionParser' | 'DefaultOptionParser'> = {
	names: () => [ 'OptionParser', 'DefaultOptionParser', ],
	knownParsers: () => ({ 'OptionParser': new OptionParser(NO_PARSERS), 'DefaultOptionParser': new OptionParser(NO_PARSERS, { allowDefault: true, }), }),
	toplevel: () => [],
}
describe.skip('OptionsParser', () => {
	const optionsParser = new OptionsParser(PARSERS)

	function parse(text: string) {
		return optionsParser.parse(null, text, 0, text.length)
	}

	it('parses empty options when document contains empty options block', () => {
		const result = parse('{}')

		expect(result).not.toBeNull()
		expect(result?.start).toEqual(0)
		expect(result?.length).toEqual(2)
		expect(result?.asMap).toEqual({})
	})
	it('does not parse options when the closing curly bracket is missing', () => {
		const result = parse('{')

		expect(result).toBeNull()
	})

	it('parses key-value option at start of the options block', () => {
		const options = '{ foo = bar}'

		const result = parse(options)

		expect(result?.asMap).toHaveProperty('foo', 'bar')
		expect(result?.length).toEqual(options.length)
	})

	it('parses default option at start of the options block', () => {
		const options = '{ the-value }'

		const result = parse(options)

		expect(result?.asMap).toHaveProperty('default', 'the-value')
		expect(result?.length).toEqual(options.length)
	})

	it('parses named option after default option', () => {
		const options = '{ the-value; k1 = v1 }'

		const result = parse(options)

		expect(result?.asMap).toHaveProperty('k1', 'v1')
		expect(result?.options.length).toEqual(2)
	})
	it('parses named option after named option', () => {
		const options = '{ k1 = v1; k2 = v2 }'

		const result = parse(options)

		expect(result?.asMap).toHaveProperty('k2', 'v2')
		expect(result?.options.length).toEqual(2)
	})

	it('stops parsing when there is a default option after a named option', () => {
		const options = '{ k1 = v1; illegal-value }'

		const result = parse(options)

		expect(result).toBeNull()
	})

	const textTestData: string[] = ['{}', '{ default }', '{     default; }', '{foo     =     bar; foobar = baz   }']
	textTestData.forEach(options => it(`generates text ${options} after parsing ${options}`, () => {
		const result = parse(options)

		expect(result?.asText).toEqual(options)
	}))

	it('prepares for parsing next options line when the previous line ended with "  "', () => {
		const options = '{ default-value  \n k1 = v1 }'
		const firstParseLength = '{ default-value  \n'.length
		const result = optionsParser.parse(null, options, 0, firstParseLength)

		expect(result).not.toBeNull()
		expect(result?.start).toEqual(0)
		expect(result?.length).toEqual(firstParseLength)
	})

	it('parses next options line when the previous line ended with "  "', () => {
		const options = '{ default-value  \n k1 = v1 }'
		const firstParseLength = '{ default-value  '.length + '\n'.length
		const secondParseStart = firstParseLength
		const secondParseLength = ' k1 = v1 }'.length
		let result = optionsParser.parse(null, options, 0, firstParseLength)
		result = optionsParser.parse(result, options, secondParseStart, secondParseLength)

		expect(result).not.toBeNull()
		expect(result?.start).toEqual(0)
		expect(result?.length).toEqual(options.length)

		expect(result?.asMap).toHaveProperty('default', 'default-value')
		expect(result?.asMap).toHaveProperty('k1', 'v1')
	})

	describe('partial parsing options', () => {
		it('updates existing option, partially', () => {
			const change: ContentChange = {
				rangeOffset: '{ default;   key'.length, rangeLength: 1, text: 'changed', range: undefined,
			}
			const options = parse('{ default;   key1   = value1; }')
			expect(options).not.toBeNull()

			const result = options!.parsedWith!.parsePartial(options!, change) as UpdatableOptions

			expect(result).not.toBeNull()
			expect(result?.asMap).toHaveProperty('keychanged', 'value1')
		})

		it('does not update option when start is -1 updates existing option, partially', () => {
			const change: ContentChange = {
				rangeOffset: 0, rangeLength: 1, text: 'changed', range: undefined,
			}
			const options = parse('{ default;   key1   = value1; }')
			options!.start = -1
			expect(options).not.toBeNull()

			const result = options!.parsedWith!.parsePartial(options!, change)

			expect(result).toBeNull()
		})


		it('updates existing default option, partially', () => {
			const change: ContentChange = {
				rangeOffset: '{ '.length, rangeLength: 0, text: 'value', range: undefined,
			}
			const options = parse('{ default;   key1   = value1; }')
			expect(options).not.toBeNull()

			const result = options!.parsedWith!.parsePartial(options!, change) as UpdatableOptions

			expect(result).not.toBeNull()
			expect(result?.asMap).toHaveProperty('default', 'valuedefault')
		})

		it('updates existing default option, at the end of the option', () => {
			const change: ContentChange = {
				rangeOffset: '{ default'.length, rangeLength: 0, text: 'value', range: undefined,
			}
			const options = parse('{ default;   key1   = value1; }')
			expect(options).not.toBeNull()

			const result = options!.parsedWith!.parsePartial(options!, change) as UpdatableOptions

			expect(result).not.toBeNull()
			expect(result?.asMap).toHaveProperty('default', 'defaultvalue')
		})

		it('updates existing options block outside of option', () => {
			const change: ContentChange = {
				rangeOffset: '{'.length, rangeLength: 0, text: 'defaultvalue;', range: undefined,
			}
			const options = parse('{    key1   = value1; }')
			expect(options).not.toBeNull()
			expect(options?.asMap).toHaveProperty('key1', 'value1')
			expect(options?.asMap).not.toHaveProperty('default')

			const result = options!.parsedWith!.parsePartial(options!, change) as UpdatableOptions

			expect(result).not.toBeNull()
			expect(options?.asMap).toHaveProperty('key1', 'value1')
			expect(result?.asMap).toHaveProperty('default', 'defaultvalue')
		})

		const baseOptions = () => (parse('{ defaultValue; foo=bar; }') as UpdatableOptions)
		const existingOptions =() => new UpdatableOptions(baseOptions()!.parts as (string | Option)[], 7, baseOptions()!.parsedWith as OptionsParser)
		const textTestData: [string, ContentChange, string][] = [
			['{}', { rangeOffset: 1, rangeLength: 0, text: ' content ', range: undefined }, '{ content }'],
			['{ default }', { rangeOffset: '{ de'.length, rangeLength: 3, text: '', range: undefined }, '{ delt }'],
			['{     default; }', { rangeOffset: 3, rangeLength: 0, text: 'foo =', range: undefined }, '{  foo =   default; }'],
			['{foo=bar}', { rangeOffset: '{foo='.length, rangeLength: 0, text: 'i', range: undefined }, '{foo=ibar}'],
			['{default;   foo=bar;}', { rangeOffset: '{default; '.length, rangeLength: 0, text: 'a=b;', range: undefined }, '{default; a=b;  foo=bar;}'],
		]
		textTestData.forEach(([options, change, newText]) => it(`updates text to ${newText} after parsing change ${JSON.stringify(change)} in ${options}`, () => {
			const parsed = parse(options)
	
			const result = parsed?.parsedWith!.parsePartial(parsed, change)

			expect(result?.asText).toEqual(newText)
		}))

		const indexTestData: [ContentChange, {start: number, length: number}][] = [
			[{ rangeOffset: '{ default'.length+7, rangeLength: 'Value'.length, text: '', range: undefined }, { start: 7, length: existingOptions().length-'Value'.length}],
			[{ rangeOffset: '{ defaultValue; foo='.length+7, rangeLength: 0, text: 'i', range: undefined }, { start: 7, length: existingOptions().length+'i'.length}],
		]
		indexTestData.forEach(([change, indexData]) => it(`Updates index data to ${JSON.stringify(indexData)} after change ${JSON.stringify(change)}`, () => {
			const result = existingOptions()!.parsedWith!.parsePartial(existingOptions(), change)

			expect(result).toEqual(expect.objectContaining(indexData))
		}))

		const outOfBoundsTestdata: ContentChange[] = [
			{ rangeOffset: 6, rangeLength: 'Value'.length, text: '', range: undefined },
			{ rangeOffset: existingOptions().length+7+5, rangeLength: 'Value'.length, text: '', range: undefined },
			{ rangeOffset: existingOptions().length+7-5, rangeLength: 'long text'.length, text: '', range: undefined },
		]
		outOfBoundsTestdata.forEach(change => it(`Does not parse out-of-bounds change ${JSON.stringify(change)}`, () => {
			const result = existingOptions()!.parsedWith!.parsePartial(existingOptions(), change)

			expect(result).toBeNull()
		}))
	})
})
